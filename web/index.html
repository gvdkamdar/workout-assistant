<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Rep Counter (Browser Camera)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            color-scheme: light dark;
        }

        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            margin: 0;
            padding: 24px;
            background: #111;
            color: #eee;
        }

        .wrap {
            max-width: 820px;
            margin: 0 auto;
        }

        h2 {
            margin: 0 0 16px;
            font-size: 28px;
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .card {
            padding: 14px 16px;
            border-radius: 12px;
            background: #181818;
            box-shadow: 0 2px 10px rgba(0, 0, 0, .28);
            margin-top: 12px;
        }

        button {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid #333;
            background: #242424;
            color: #eee;
            cursor: pointer;
        }

        button:hover {
            background: #2d2d2d;
        }

        select,
        label {
            color: #eee;
        }

        select {
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid #333;
            background: #242424;
        }

        #count {
            font-size: 64px;
            font-weight: 800;
            line-height: 1;
        }

        #status {
            color: #aaa;
            font-size: 14px;
            margin-top: 6px;
        }

        .hudgrid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .hudgrid div {
            font-variant-numeric: tabular-nums;
        }

        .muted {
            opacity: .7
        }

        /* NEW: stage for overlay canvas */
        .stage {
            position: relative;
            width: 100%;
        }

        #video,
        #overlay {
            width: 100%;
            display: block;
            border-radius: 16px;
        }

        #overlay {
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: none;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h2>Rep Counter (Browser Camera)</h2>

        <div class="row">
            <button id="btnStart">Start</button>
            <button id="btnStop">Stop</button>
            <label>Exercise:
                <select id="exercise">
                    <option value="bicep_curl">Bicep Curl</option>
                    <option value="bench_press">Bench Press</option>
                    <option value="lateral_raise">Lateral Raise</option>
                    <option value="shoulder_press">Shoulder Press</option>
                </select>
            </label>
            <label>Side:
                <select id="side">
                    <option value="right" selected>Right</option>
                    <option value="left">Left</option>
                    <option value="both">Both</option>
                </select>
            </label>
        </div>

        <div class="card">
            <div id="count">0</div>
            <div id="status">idle</div>
        </div>

        <div class="card">
            <div class="hudgrid">
                <div>angle: <span id="hudAngle" class="muted">–</span>°</div>
                <div>ROM: <span id="hudRom" class="muted">–</span>°</div>
                <div>vel: <span id="hudVel" class="muted">–</span>°/s</div>
            </div>
        </div>

        <!-- NEW: router/tool TRACE -->
        <div class="card">
            <div style="font-weight:600;margin-bottom:6px;">Trace</div>
            <pre id="traceLog" style="max-height:180px; overflow:auto;">(ready)</pre>
        </div>

        <div class="card">
            <div style="position:relative; width:100%; max-width:720px;">
                <video id="video" playsinline autoplay muted
                    style="width:100%; border-radius:16px; background:#000;"></video>
                <canvas id="overlay"
                    style="position:absolute; inset:0; width:100%; height:100%; pointer-events:none;"></canvas>
            </div>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, PoseLandmarker } from "https://unpkg.com/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

        const $ = s => document.querySelector(s);
        const statusEl = $("#status");
        const countEl = $("#count");
        const videoEl = $("#video");
        // const overlay = $("#overlay");
        const overlay = document.getElementById("overlay");
        const ctx = overlay.getContext("2d");
        const btnStart = $("#btnStart");
        const btnStop = $("#btnStop");
        const selEx = $("#exercise");
        const selSide = $("#side");
        // const hudAngle = $("#hudAngle");
        // const hudRom = $("#hudRom");
        // const hudVel = $("#hudVel");
        const hudAngle = document.getElementById("hudAngle");
        const hudRom = document.getElementById("hudRom");
        const hudVel = document.getElementById("hudVel");
        const traceEl = $("#traceLog");

        let ws, pose = 0;
        let mediaStream = null, streaming = false;
        let lastSpoken = 0;

        // HUD trackers (client-side for display)
        let hudMin = 1e9, hudMax = -1e9, lastAngle = null, lastTs = null;

        function logTrace(msg) {
            const t = new Date().toLocaleTimeString();
            traceEl.textContent += `\n[${t}] ${msg}`;
            traceEl.scrollTop = traceEl.scrollHeight;
        }

        const speak = (t) => { try { speechSynthesis.cancel(); speechSynthesis.speak(new SpeechSynthesisUtterance(String(t))); } catch (e) { } };

        async function initPose() {
            if (pose) return;
            const vision = await FilesetResolver.forVisionTasks(
                "https://unpkg.com/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            pose = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task"
                },
                runningMode: "VIDEO",
                numPoses: 1
            });
            logTrace("pose model ready");
        }

        async function initCamera() {
            mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
            videoEl.srcObject = mediaStream;
            await new Promise(r => videoEl.onloadedmetadata = r);
            await videoEl.play();
            // sync overlay to video intrinsic size
            overlay.width = videoEl.videoWidth || 640;
            overlay.height = videoEl.videoHeight || 480;
            ensureOverlaySize();                  // ← add this
            statusEl.textContent = "camera ready";
            logTrace(`camera ready (${overlay.width}×${overlay.height})`);
        }

        function connectWS() {
            if (ws && ws.readyState === WebSocket.OPEN) return;
            ws = new WebSocket((location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws/angles");
            ws.onopen = () => { logTrace("ws open (angles→server)"); };
            ws.onclose = () => { logTrace("ws closed"); };
            ws.onerror = (e) => { logTrace("ws error"); console.error(e); };
            // NEW: listen to server→client events (rep, partial, trace)
            ws.onmessage = (ev) => {
                try {
                    const msg = JSON.parse(ev.data);
                    if (msg.type === "trace") {
                        logTrace(msg.msg || JSON.stringify(msg));
                    } else if (msg.type === "rep") {
                        // Optional: update count immediately
                        if (typeof msg.count === "number") {
                            countEl.textContent = String(msg.count);
                            speak(msg.count);
                        }
                        logTrace(`rep counted → ${msg.count}`);
                    } else if (msg.type === "partial") {
                        logTrace(`partial rep (${msg.reason || "unknown"})`);
                    }
                } catch { }
            };
        }

        function angle3(a, b, c) {
            const ang = Math.atan2(c[1] - b[1], c[0] - b[0]) - Math.atan2(a[1] - b[1], a[0] - b[0]);
            let deg = Math.abs(ang * 180 / Math.PI);
            if (deg > 180) deg = 360 - deg;
            return deg;
        }

        function ensureOverlaySize() {
            // Match canvas pixel size to CSS size for crisp lines
            const rect = videoEl.getBoundingClientRect();
            overlay.width = Math.max(1, Math.round(rect.width * devicePixelRatio));
            overlay.height = Math.max(1, Math.round(rect.height * devicePixelRatio));
        }
        window.addEventListener("resize", ensureOverlaySize);


        // NEW: draw shoulder–elbow–wrist and angle text
        function drawSkeleton(lm, side, angle, which = "right") {
            const idx = (which === "left") ? { S: 11, E: 13, W: 15 } : { S: 12, E: 14, W: 16 };
            const S = lm[idx.S], E = lm[idx.E], W = lm[idx.W];
            if (!S || !E || !W) return;

            const x = p => (p.x * overlay.width);
            const y = p => (p.y * overlay.height);

            ctx.lineWidth = 4;
            ctx.strokeStyle = which === "left" ? "#80b3ff" : "#8af59b";
            ctx.fillStyle = ctx.strokeStyle;

            // limb lines
            ctx.beginPath(); ctx.moveTo(x(S), y(S)); ctx.lineTo(x(E), y(E)); ctx.lineTo(x(W), y(W)); ctx.stroke();

            // joints
            const r = 5;
            ctx.beginPath(); ctx.arc(x(S), y(S), r, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x(E), y(E), r, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x(W), y(W), r, 0, Math.PI * 2); ctx.fill();

            // angle label near elbow
            ctx.font = "16px ui-monospace, monospace";
            ctx.fillText(`${angle.toFixed(0)}°`, x(E) + 8, y(E) - 8);
        }


        function drawDot(p) {
            ctx.beginPath();
            ctx.arc(p[0], p[1], 6 * devicePixelRatio, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255,255,255,0.95)";
            ctx.fill();
            ctx.lineWidth = 2 * devicePixelRatio;
            ctx.strokeStyle = "rgba(0,0,0,0.4)";
            ctx.stroke();
        }

        function drawJointLine(p1, p2) {
            ctx.beginPath();
            ctx.moveTo(p1[0], p1[1]);
            ctx.lineTo(p2[0], p2[1]);
            ctx.lineWidth = 4 * devicePixelRatio;
            ctx.strokeStyle = "rgba(0,200,255,0.9)";
            ctx.stroke();
        }

        // reuse your existing angle function if you like; this one is local to loop
        function elbowAngle(a, b, c) {
            const ang = Math.atan2(c[1] - b[1], c[0] - b[0]) - Math.atan2(a[1] - b[1], a[0] - b[0]);
            let deg = Math.abs(ang * 180 / Math.PI);
            if (deg > 180) deg = 360 - deg;
            return deg;
        }


        // // NEW: loop for 2D landmarks (landmarks are in normalized coords)
        // async function loop() {
        //     if (!streaming) return;
        //     if (!pose || videoEl.readyState < 2) { requestAnimationFrame(loop); return; }
        //     const now = performance.now();
        //     const result = await pose.detectForVideo(videoEl, now);
        //     ctx.clearRect(0, 0, overlay.width, overlay.height);

        //     if (result && result.landmarks && result.landmarks[0]) {
        //         const lm = result.landmarks[0];
        //         const side = selSide.value;
        //         const L = [lm[11], lm[13], lm[15]];
        //         const R = [lm[12], lm[14], lm[16]];
        //         const pt = p => [p.x, p.y];

        //         let values = [];
        //         if (side === "left" || side === "both") values.push({ which: "left", angle: angle3(pt(L[0]), pt(L[1]), pt(L[2])) });
        //         if (side === "right" || side === "both") values.push({ which: "right", angle: angle3(pt(R[0]), pt(R[1]), pt(R[2])) });

        //         if (values.length) {
        //             // average for sending, but draw each side
        //             const avgAngle = values.reduce((a, b) => a + b.angle, 0) / values.length;

        //             // HUD update always
        //             const ts = performance.now() / 1000;
        //             if (lastAngle == null) { lastAngle = avgAngle; lastTs = ts; }
        //             const dt = Math.max(1e-3, ts - lastTs);
        //             const vel = (avgAngle - lastAngle) / dt;
        //             lastAngle = avgAngle; lastTs = ts;

        //             hudMin = Math.min(hudMin, avgAngle);
        //             hudMax = Math.max(hudMax, avgAngle);
        //             const rom = hudMax - hudMin;
        //             hudAngle.textContent = avgAngle.toFixed(1);
        //             hudRom.textContent = rom.toFixed(1);
        //             hudVel.textContent = vel.toFixed(1);

        //             // draw overlay for each measured side
        //             for (const v of values) drawSkeleton(lm, side, v.angle, v.which);

        //             // send to server if ws open
        //             if (ws && ws.readyState === WebSocket.OPEN) {
        //                 ws.send(JSON.stringify({ type: "angle", angle: avgAngle, ts: Date.now() / 1000, side }));
        //             }
        //         }
        //     }
        //     requestAnimationFrame(loop);
        // }


        async function loop() {
            if (!streaming) return;

            if (!pose || videoEl.readyState < 2) {
                requestAnimationFrame(loop);
                return;
            }

            const now = performance.now();
            const result = await pose.detectForVideo(videoEl, now);

            // Clear overlay each frame
            ctx.clearRect(0, 0, overlay.width, overlay.height);

            if (result && result.landmarks && result.landmarks[0]) {
                const lm = result.landmarks[0];

                // convert normalized coords to canvas pixels
                const toPx = p => [p.x * overlay.width, p.y * overlay.height];

                // left/right triples: shoulder–elbow–wrist
                const L = [lm[11], lm[13], lm[15]].map(toPx);
                const R = [lm[12], lm[14], lm[16]].map(toPx);

                // decide which to use for angle (match UI selector)
                const side = selSide.value;
                let samples = [];
                if (side === "left" || side === "both") samples.push(L);
                if (side === "right" || side === "both") samples.push(R);

                // draw and compute angles
                let angles = [];
                for (const tri of samples) {
                    const [S, E, W] = tri;
                    drawJointLine(S, E);
                    drawJointLine(E, W);
                    drawDot(S); drawDot(E); drawDot(W);

                    angles.push(elbowAngle(S, E, W));
                }

                if (angles.length) {
                    const angle = angles.reduce((a, b) => a + b, 0) / angles.length;

                    // HUD: angle, velocity, ROM (client-side)
                    const tsec = now / 1000.0;
                    if (lastAngle == null) { lastAngle = angle; lastTs = tsec; }
                    const dt = Math.max(1e-3, tsec - lastTs);
                    const vel = (angle - lastAngle) / dt;
                    lastAngle = angle; lastTs = tsec;

                    // per-"set" HUD ROM; reset on Start button in your code
                    hudMin = Math.min(hudMin, angle);
                    hudMax = Math.max(hudMax, angle);

                    hudAngle.textContent = angle.toFixed(1);
                    hudVel.textContent = Math.abs(vel).toFixed(1);
                    hudRom.textContent = (hudMax - hudMin).toFixed(1);

                    // send the averaged angle to server if WS is open
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: "angle", angle, ts: tsec, side }));
                    }
                }
            }

            requestAnimationFrame(loop);
        }

        // polling (throttled) – only while running
        let pollTimer = null;
        function startPolling() {
            if (pollTimer) return;
            pollTimer = setInterval(async () => {
                try {
                    const r = await fetch("/sessions/current");
                    if (!r.ok) return;
                    const j = await r.json();
                    countEl.textContent = String(j.count || 0);
                    statusEl.textContent = `${j.state}${j.web_mode ? " (web)" : ""}`;
                    const n = Number(j.count || 0);
                    if (n > lastSpoken) { speak(n); lastSpoken = n; }
                } catch (e) { }
            }, 800);
        }
        function stopPolling() {
            if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
        }

        btnStart.onclick = async () => {
            logTrace(`router: start → ${selEx.value} (${selSide.value})`);
            connectWS();
            // Load model only once
            if (!pose) {
                await initPose();
            }
            if (!navigator.mediaDevices?.getUserMedia) {
                statusEl.textContent = (location.hostname === "0.0.0.0")
                    ? "Open at http://localhost:8000 (0.0.0.0 blocks camera)."
                    : "Camera API unavailable. Use https or localhost.";
                return;
            }
            if (!mediaStream) {
                await initCamera(); // ensureOverlaySize() should run inside initCamera()
            }

            hudMin = 1e9; hudMax = -1e9; lastAngle = null; lastTs = null;
            hudAngle.textContent = "–"; hudRom.textContent = "–"; hudVel.textContent = "–";

            streaming = true; lastSpoken = 0;
            loop();
            await fetch(`/counter/start?exercise=${encodeURIComponent(selEx.value)}&side=${encodeURIComponent(selSide.value)}`, { method: "POST" });
            speak(`starting ${selEx.value.replace("_", " ")}`);
            startPolling();
        };

        btnStop.onclick = async () => {
            streaming = false;
            try {
                if (mediaStream) {
                    mediaStream.getTracks().forEach(t => t.stop());
                    mediaStream = null;
                }
                videoEl.srcObject = null;
            } catch (e) { }
            try { if (ws && ws.readyState === WebSocket.OPEN) ws.close(); } catch (e) { }
            await fetch("/counter/stop", { method: "POST" });
            speak("stopping");
            stopPolling();
            // HUD reset
            hudMin = 1e9; hudMax = -1e9; lastAngle = null; lastTs = null;
            hudAngle.textContent = "–"; hudRom.textContent = "–"; hudVel.textContent = "–";

            const ctx = overlay.getContext("2d");
            ctx.clearRect(0, 0, overlay.width, overlay.height);
            logTrace("router: stop");
        };

        connectWS(); // flip web_mode, but don’t start camera yet
    </script>
</body>

</html>